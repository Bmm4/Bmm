#!/usr/bin/env perl

#
# $BMMBASE/perl/pdTriggers -a -s /frozen/... 
#
# -- dump all specific trigger in all trigger menus
# $BMMBASE/perl/pdTriggers -b -s /frozen/... -p Charmonium -t DoubleMu4_3_Bs
#
# -- dump triggers with pattern $opt_t in name:
# $BMMBASE/perl/pdTriggers -b -s /frozen/2015/25ns14e33/v4.0/HLT/V4 -t Displaced
#
# -- dump all datasets in all trigger menus
# $BMMBASE/perl/pdTriggers -c
#
# -- dump contents of PD vs version
# $BMMBASE/perl/pdTriggers -b -p SingleMuon
#
# -a works only at CERN!?
# -b works everywhere if you have the ascii files 
#
# ----------------------------------------------------------------------
# Send all questions, wishes and complaints to the 
#
# Author    Urs Langenegger <urs.langenegger@gmail.com>
# ----------------------------------------------------------------------

use lib "$ENV{BMMBASE}/perl/modules/Tie-IxHash-1.23/lib"; 
use Tie::IxHash;

use Getopt::Std;
getopts('abBcDp:s:t:v');

my $command = "hltConfigFromDB --offline --configName "; 

# -- allow either /frozen/... or menu__frozen__... version
if ($opt_s =~ /__/) {
    $opt_s =~ s%__%/%g;
    $opt_s =~ s%menu%%g;
    #print "==> $opt_s\n";
}

my @skipPD = (
    "Commissioning", 
    "HLTPhysics", "HLTMonitor", "LookAreaPD", "OnlineMonitor", "InitialPD", "L1Accept",
    "RPCMonitor",
    "FullTrack", "Templates", 
    "HighMultiplicity85", "HighMultplicity85",
    "MonteCarlo", 
    "ParkingHT1", "ParkingHT2", "ParkingHT3", "ParkingHT4", "ParkingHT5", "ParkingMonitor", 
    "AlCaP0", "AlCaPhiSym", "AlCaLumiPixels", "AlCaElectron", 
    "DQMOfflinePD", "TestEnablesEcalHcalDQM", 
    "HINCaloJetsOther", "HINCaloJets", "HINPFJets", "HINPFJetsOther", "HINPhoton", "HINMuon", 
    "Test", "ElectronStream", 
    "HcalHPDNoise", "HCalNZS", "HcalNZS", "TestEnablesEcalHcal", "TestEnablesEcalHcalDQM", "HcalHPDNoise", 
    "EcalLaser", "NoBPTX", 
    "ToTOTEM",
    "Express", "ExpressPhysics", "EventDisplay"
    );
    


# -- from https://twiki.cern.ch/twiki/bin/view/CMS/ConfDB740#Frozen_menus
my @twikiMenus = ( 
    "/frozen/2015/25ns14e33/v4.0/HLT/V4",
    "/frozen/2015/25ns14e33/v4.0/HLT/V1",
    "/frozen/2015/25ns14e33/v3.3/HLT/V2",
    "/frozen/2015/25ns14e33/v3.3/HLT/V1",
    "/frozen/2015/25ns14e33/v3.1/HLT/V3",
    "/frozen/2015/25ns14e33/v3.1/HLT/V2",
    "/frozen/2015/25ns14e33/v3.1/HLT/V1",
    "/frozen/2015/25ns14e33/v3.0/HLT/V1",
    "/frozen/2015/25ns14e33/v2.2/HLT/V2",
    "/frozen/2015/25ns14e33/v2.2/HLT/V1",
    "/frozen/2015/25ns14e33/v2.1/HLT/V1",
    "/frozen/2015/25ns14e33/v2.0/HLT/V2",
    "/frozen/2015/25ns14e33/v1.2/HLT/V2",
    "/frozen/2015/25ns14e33/v1.1/HLT/V2",
    "/frozen/2015/25ns14e33/v1.0/HLT/V3",
    "/frozen/2015/25ns14e33/v1.0/HLT/V1",

    "/frozen/2015/50ns_5e33/v3.4/HLT/V1",
#    "/frozen/2015/50ns_5e33/v3.0/HLT/V2",
    "/frozen/2015/50ns_5e33/v2.2/HLT/V2",
    "/frozen/2015/50ns_5e33/v2.2/HLT/V1",
    "/frozen/2015/50ns_5e33/v2.1/HLT/V5",
    "/frozen/2015/50ns_5e33/v2.1/HLT/V3",
    "/frozen/2015/50ns_5e33/v2.0/HLT/V3",
    "/frozen/2015/50ns_5e33/v2.0/HLT/V2",
    "/frozen/2015/50ns_5e33/v1.2/HLT/V2",
    "/frozen/2015/50ns_5e33/v1.1/HLT/V2",
    "/frozen/2015/50ns_5e33/v1.0/HLT/V3",
    "/frozen/2015/50ns_5e33/v1.0/HLT/V1"
    ); 

my @menus = reverse @twikiMenus;


# %%%%%%%%%%%%%%
# -- cmsRun part
# %%%%%%%%%%%%%%
if ($opt_a) {
    my $file = ""; 
    foreach $menu (@menus) {
	if ($opt_s && ($menu ne $opt_s)) {
	    next;
	}
	($file = "menu".$menu) =~ s%/%__%g;
	print "$command $menu > $file\n";
	system("$command $menu > $file");
    }
    exit(0); 
}



# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# -- call this for a selection of PD
# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if ($opt_B) {
    $pdlist = `$ENV{BMMBASE}/perl/pdTriggers -b`;
    @pd = split(/\n/, $pdlist); 
    foreach (@pd) {
	system("$ENV{BMMBASE}/perl/pdTriggers -p $_");
    }
    
    print "\n";
    exit(0); 
}


# %%%%%%%%%%%%%%%%%%%%%%%%%%
# -- Analysis of ASCII files
# %%%%%%%%%%%%%%%%%%%%%%%%%%
my  %pdmenu = ();
tie %pdmenu, "Tie::IxHash";

my  %pdTrigger = (); 
tie %pdTrigger, "Tie::IxHash";


my  %cumulativeTriggers = (); 
tie %cumulativeTriggers, "Tie::IxHash";

# -- set up %pdmenu that contains all PD and trigger menus
my $file = ""; 
foreach $menu (@menus) {
    if ($opt_s && ($menu ne $opt_s)) {
	next;
    }
    ($file = "menu".$menu) =~ s%/%__%g;
    open(IN, "$file") || die "cannot open $file\n";
    # -- go to pdmenu definition:
    while (<IN>) {
	if (/process.datasets/) {
	    last;
	}
    }	    
    readPD(IN, $menu);
    close(IN);
}


my  %menus = (); 
tie %menus, "Tie::IxHash";
foreach $key (keys %pdmenu) {
    ($pd, $menu) = split(/:/, $key); 
    $menus{$menu} = 1; 
    $pds{$pd} = 1; 
}


if ($opt_b) {
    foreach (keys %pds) {
	print "$_\n";
    }
    exit(0);
}


if ($opt_c) {
    foreach (keys %menus) {
	print "$_\n";
    }
    exit(0);
}

# -- print all triggers in PD $opt_p
if ($opt_p) {
    my $oldmenu = ""; 
    my $old     = ""; 
    foreach $key (keys %pdmenu) {
	($pd, $menu) = split(/:/, $key); 
	#print "$key -> pd = $pd, menu = $menu\n** $pdmenu{$key}\n** $old\n\n";
	if ($pd ne $opt_p) {next;}
	if ($menu ne $oldmenu) {
	    @vMenu = split(/,/, $pdmenu{$key}); 
	    @vOld = split(/,/, $old); 
	    %adiff = newVsOld(\@vMenu, \@vOld);
	    $old = $pdmenu{$key};
	    
	    ($line = $pdmenu{$key}) =~ s/,/\n/g;
	    ($pd = $key) =~ s/:.*$//g;
	    print "******** $key ********\n";
	    foreach $dkey (keys %adiff) {
		#print "adiff: $dkey = $adiff{$dkey}\n";
		if ($adiff{$dkey} == 1) {
		    print "added $dkey \n";
		    $cumulativeTriggers{$pd} .= "$dkey\n";
		} elsif ($adiff{$dkey} == 2) {
		    print "removed $dkey \n";
		}
	    }

	    $oldmenu = $menu; 
	}
    }

    foreach $key (keys %cumulativeTriggers) {
	open(OUT, ">$key.triggers") || die "cannot open $key.triggers\n";
	print OUT "# ***************************************************************\n";
	print OUT "# $key cumulative trigger list from trigger menus:\n";
	foreach (keys %menus) {
	    print OUT "# $_\n";
	}
	
	print OUT "# ***************************************************************\n";
	print OUT "$cumulativeTriggers{$key}";
	close OUT;
    }
}




exit(0);

# ----------------------------------------------------------------------
sub readPD() {
    ($in, $lmenu) = @_;
    my $hlts = ""; 
    my $name = ""; 
    my $fullName = ""; 
    while (42) {
	$line = <$in>; 
	if ($line =~ /^\)/) {
	    last;
	}
	if ($line =~ /=/) {
	    ($name, $rest) = split(/=/, $line); 
	    $name =~ s/\s*//g;
	    $rest =~ /'(.*)'/; 
	    $hlt = $1; 
	} else {
	    $line =~ /'(.*)'/; 
	    $hlt = $1; 
	}
	$hlt =~ s/_v[0-9]*$//g;
	if ($opt_t) {
	    if ($hlt =~ $opt_t) {
		$hlts = $hlts . $hlt . ","; 
	    } 
	} else {
	    $hlts = $hlts . $hlt . ","; 
	} 

	if ($line =~ /\),/) {
	    $hlts =~ s/,$//g;
	    if (grep /$name/, @skipPD) {
		#print "found $name in skipPD, skipping\n";
	    } else {
		$fullName = $name . ":" . $menu;
		if ($opt_p) {
		    if ($name eq $opt_p) {
			$pdmenu{$fullName} = $hlts;
		    }
		} else {
		    $pdmenu{$fullName} = $hlts;
		}
	    }
	    $hlts = ""; 
	    $name = ""; 
	}
    }
}


# ----------------------------------------------------------------------
sub splitIntoArray() {
    ($in) = @_;
    return
}

# ----------------------------------------------------------------------
sub newVsOld {
    my ($array1, $array2) = @_;

    my @array1 = @{$array1};
    my @array2 = @{$array2};

    #print "size array1: $#array1\n";
    #print "size array2: $#array2\n";

    my %count = (); 
    foreach (@array1) {
	$count{$_} = 1;
    };
    foreach (@array2) {
	if ($count{$_} == 1) {
	    #print "$_ already in array1\n";
	    $count{$_} = 3; 
	} else {
	    #print "** $_ not in array1\n";
	    $count{$_} = 2;
	}
    }
    return %count; 
}
